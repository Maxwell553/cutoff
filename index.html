<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko Mini - Multiplier Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        #startButton {
            position: absolute;
            top: 150px;
            left: 300px;
            transform: translate(-50%, -50%);
            z-index: 1000;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            background: #00ff00;
            border: 2px solid #00ff00;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
            transition: all 0.3s ease;
        }
        #startButton:hover {
            background: #00cc00;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.9);
            transform: translate(-50%, -50%) scale(1.05);
        }
        #startButton.hidden {
            display: none;
        }
        #restartButton {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            background: rgba(255, 100, 100, 0.8);
            border: 2px solid #ff6464;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.5);
            transition: all 0.3s ease;
        }
        #restartButton:hover {
            background: rgba(255, 100, 100, 1);
            box-shadow: 0 0 25px rgba(255, 100, 100, 0.8);
            transform: scale(1.05);
        }
        #restartButton.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <button id="startButton">Start</button>
        <button id="restartButton" class="hidden">Restart</button>
    </div>

    <script>
        // ============================================
        // PLINKO MINI - MULTIPLIER GAME
        // ============================================
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 800;
        const BALL_RADIUS = 5; // Smaller ball
        const PEG_RADIUS = 5;
        const GRAVITY = 400;
        const BOUNCE_DAMPING = 0.9; // More bouncy (increased from 0.7)
        const FRICTION = 0.98;
        
        // Triangle parameters (smaller triangle)
        const TRIANGLE_TOP_Y = 150;
        const TRIANGLE_BOTTOM_Y = 400;
        const TRIANGLE_LEFT_X = 200;
        const TRIANGLE_RIGHT_X = 400;
        const TRIANGLE_CENTER_X = (TRIANGLE_LEFT_X + TRIANGLE_RIGHT_X) / 2;
        const TRIANGLE_WIDTH = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
        const ROWS = 6; // 6 layers: 3, 4, 5, 6, 7, 8 pegs
        const PEG_SPACING_X = (TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X) / (ROWS + 1);
        const PEG_SPACING_Y = (TRIANGLE_BOTTOM_Y - TRIANGLE_TOP_Y) / ROWS;
        
        // Multiplier boxes - positioned directly under pegs
        const MULTIPLIER_Y = TRIANGLE_BOTTOM_Y + 2; // Only 2 pixels below the pegs
        const MULTIPLIER_HEIGHT = 30; // Larger boxes
        const MULTIPLIERS = [10, 4, 4, 10]; // Removed x2 box
        // Widths: each box spans 2 pegs, spaced evenly
        const MULTIPLIER_WIDTH = PEG_SPACING_X * 1.8; // Larger width for better visibility
        
        // Fluid collection circle (regular circle, wide enough, closer to multipliers)
        const FLUID_CIRCLE_X = CANVAS_WIDTH / 2;
        const FLUID_CIRCLE_Y = MULTIPLIER_Y + MULTIPLIER_HEIGHT + 20; // Moved up more, less gap
        const FLUID_CIRCLE_RADIUS = TRIANGLE_WIDTH * 0.705675; // Reduced by another 3% (0.7275 * 0.97)
        const FLUID_PARTICLES_PER_BALL = 10; // Reduced to prevent lag from overlapping
        
        // Ball color cycle (Red → Green → Blue gradient like ballgame.html)
        const BALL_COLOR_CYCLE_MIN = 2.5;
        const BALL_COLOR_CYCLE_MAX = 3.0;
        
        // Global state
        let balls = [];
        let pegs = [];
        let multipliers = [];
        let fluidParticles = [];
        let gameStarted = false;
        let lastFrameTime = 0;
        let ballsToDrop = 1;
        let totalBallsDropped = 0;
        let gameStopped = false; // Track if fluid reached top
        let audioContext = null;
        let lastBallDropTime = 0;
        const BALL_DROP_INTERVAL = 0.1; // Drop a ball every 0.1 seconds (faster spawn)
        
        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }
        
        // Play sound effect
        function playSound(frequency, duration, volume = 0.3) {
            try {
                const ctx = initAudioContext();
                if (ctx.state === 'suspended') {
                    ctx.resume().catch(e => console.log('Audio resume error:', e));
                }
                if (ctx.state !== 'running') return;
                
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);
                
                const now = ctx.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                oscillator.start(now);
                oscillator.stop(now + duration);
            } catch (e) {
                console.log('Audio error:', e);
            }
        }
        
        // Peg class
        class Peg {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = PEG_RADIUS;
            }
            
            draw() {
                // Glowing effect (cyan/blue like before)
                for (let i = 0; i < 3; i++) {
                    const alpha = 100 - i * 30;
                    const radius = this.radius * (1 + i * 0.2);
                    fill(100, 200, 255, alpha);
                    noStroke();
                    ellipse(this.x, this.y, radius * 2, radius * 2);
                }
                
                // Main peg
                fill(100, 200, 255);
                noStroke();
                ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
            }
        }
        
        // Multiplier box class
        class MultiplierBox {
            constructor(x, y, multiplier, width) {
                this.x = x;
                this.y = y;
                this.width = width || MULTIPLIER_HEIGHT; // Use provided width or default
                this.height = MULTIPLIER_HEIGHT;
                this.multiplier = multiplier;
            }
            
            contains(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }
            
            // Check if a circle intersects with this box
            intersectsCircle(circleX, circleY, circleRadius) {
                // Use adjusted Y position (same as draw function)
                const adjustedY = this.y - this.height + 5;
                // Find the closest point on the box to the circle center
                const closestX = Math.max(this.x, Math.min(circleX, this.x + this.width));
                const closestY = Math.max(adjustedY, Math.min(circleY, adjustedY + this.height));
                
                // Calculate distance from circle center to closest point
                const dx = circleX - closestX;
                const dy = circleY - closestY;
                const distanceSquared = dx * dx + dy * dy;
                
                // Check if distance is less than radius
                return distanceSquared < circleRadius * circleRadius;
            }
            
            draw() {
                // Move box UP - adjust Y position to be closer to pegs
                const adjustedY = this.y - this.height + 5; // Move box up by almost its full height
                
                // Clear/transparent box with white border
                push();
                noFill();
                stroke(255, 255, 255);
                strokeWeight(2);
                rect(this.x, adjustedY, this.width, this.height);
                
                // White text (centered in the box)
                fill(255, 255, 255);
                textAlign(CENTER, CENTER);
                textSize(18); // Larger text for larger boxes
                textStyle(BOLD);
                text(`x${this.multiplier}`, this.x + this.width / 2, adjustedY + this.height / 2); // Centered text
                pop();
            }
        }
        
        // Fluid particle class
        class FluidParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = Math.random() * 50 + 20;
                this.size = Math.random() * 2.0 + 2.0; // Larger particles to reduce overlap and lag
                this.life = 1.0;
                this.maxLife = 1.0;
                this.hue = Math.random() * 60 + 180; // Cyan to blue range
                this.settled = false; // Track if particle has settled at bottom
            }
            
            update(deltaTime) {
                // Gravity
                this.vy += GRAVITY * deltaTime * 0.3;
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Check collision with other particles - proper colliders to prevent overlap
                // Optimize: use squared distance to avoid sqrt when possible
                for (let otherParticle of fluidParticles) {
                    if (otherParticle !== this) {
                        const dx = this.x - otherParticle.x;
                        const dy = this.y - otherParticle.y;
                        const distSquared = dx * dx + dy * dy;
                        const minDist = this.size + otherParticle.size;
                        const minDistSquared = minDist * minDist;
                        
                        // Only process if particles are close enough (optimization)
                        if (distSquared < minDistSquared && distSquared > 0.0001) {
                            const dist = Math.sqrt(distSquared);
                            // Collision detected - separate particles to prevent overlap
                            const angle = Math.atan2(dy, dx);
                            const normalX = Math.cos(angle);
                            const normalY = Math.sin(angle);
                            
                            // Force separation - particles cannot occupy same space (prevent clumping)
                            const overlap = minDist - dist;
                            const separationX = normalX * overlap * 0.8; // Strong separation to prevent clumping
                            const separationY = normalY * overlap * 0.8;
                            this.x += separationX;
                            this.y += separationY;
                            otherParticle.x -= separationX;
                            otherParticle.y -= separationY;
                            
                            // Add repulsion force when particles get too close to prevent clumping
                            const repulsionForce = 0.3;
                            this.vx += normalX * repulsionForce;
                            this.vy += normalY * repulsionForce;
                            otherParticle.vx -= normalX * repulsionForce;
                            otherParticle.vy -= normalY * repulsionForce;
                            
                            // CRITICAL: Force both particles to stay inside circle boundary after collision
                            const thisDx = this.x - FLUID_CIRCLE_X;
                            const thisDy = this.y - FLUID_CIRCLE_Y;
                            const thisDist = Math.sqrt(thisDx * thisDx + thisDy * thisDy);
                            const maxDist = FLUID_CIRCLE_RADIUS - this.size - 0.5; // Safety margin
                            if (thisDist > maxDist) {
                                const thisAngle = Math.atan2(thisDy, thisDx);
                                this.x = FLUID_CIRCLE_X + Math.cos(thisAngle) * maxDist;
                                this.y = FLUID_CIRCLE_Y + Math.sin(thisAngle) * maxDist;
                            }
                            
                            const otherDx = otherParticle.x - FLUID_CIRCLE_X;
                            const otherDy = otherParticle.y - FLUID_CIRCLE_Y;
                            const otherDist = Math.sqrt(otherDx * otherDx + otherDy * otherDy);
                            const otherMaxDist = FLUID_CIRCLE_RADIUS - otherParticle.size - 0.5; // Safety margin
                            if (otherDist > otherMaxDist) {
                                const otherAngle = Math.atan2(otherDy, otherDx);
                                otherParticle.x = FLUID_CIRCLE_X + Math.cos(otherAngle) * otherMaxDist;
                                otherParticle.y = FLUID_CIRCLE_Y + Math.sin(otherAngle) * otherMaxDist;
                            }
                            
                            // Exchange velocities (elastic collision) - proper physics
                            const relativeVx = this.vx - otherParticle.vx;
                            const relativeVy = this.vy - otherParticle.vy;
                            const dot = relativeVx * normalX + relativeVy * normalY;
                            
                            // Only collide if moving towards each other
                            if (dot < 0) {
                                const impulse = 2 * dot;
                                this.vx -= impulse * normalX * 0.5;
                                this.vy -= impulse * normalY * 0.5;
                                otherParticle.vx += impulse * normalX * 0.5;
                                otherParticle.vy += impulse * normalY * 0.5;
                            }
                        }
                    }
                }
                
                // Friction
                this.vx *= 0.95;
                
                // Calculate opening position (aligned with triangle walls)
                const WALL_OFFSET = PEG_RADIUS + 7;
                const lastRowPegs = 8;
                const rowWidth = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
                const lastRowWidth = (lastRowPegs - 1) * PEG_SPACING_X;
                const lastRowStartX = TRIANGLE_LEFT_X + (rowWidth - lastRowWidth) / 2;
                const lastRowEndX = lastRowStartX + lastRowWidth;
                const openingLeftX = lastRowStartX - WALL_OFFSET; // Left wall endpoint
                const openingRightX = lastRowEndX + WALL_OFFSET; // Right wall endpoint
                const openingY = FLUID_CIRCLE_Y - FLUID_CIRCLE_RADIUS;
                const openingWidth = openingRightX - openingLeftX;
                const openingHeight = Math.sqrt(FLUID_CIRCLE_RADIUS * FLUID_CIRCLE_RADIUS - 
                                              (openingWidth / 2) * (openingWidth / 2));
                const openingBottomY = openingY + openingHeight;
                
                const dx = this.x - FLUID_CIRCLE_X;
                const dy = this.y - FLUID_CIRCLE_Y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if particle is inside circle (below opening)
                const isBelowOpening = this.y > openingBottomY;
                
                if (isBelowOpening && dist < FLUID_CIRCLE_RADIUS) {
                    // IMPROVED circle collider - multiple checks to prevent particles escaping
                    const maxDist = FLUID_CIRCLE_RADIUS - this.size - 1.0; // Larger safety margin
                    
                    // Check collision with circle boundary - ensure particles stay trapped
                    if (dist > maxDist) {
                        // Bounce off circle boundary
                        const angle = Math.atan2(dy, dx);
                        const normalX = Math.cos(angle);
                        const normalY = Math.sin(angle);
                        
                        // Reflect velocity (bouncier)
                        const dot = this.vx * normalX + this.vy * normalY;
                        this.vx = (this.vx - 2 * dot * normalX) * 0.9;
                        this.vy = (this.vy - 2 * dot * normalY) * 0.9;
                        
                        // Force particle back inside - aggressive push back
                        const overlap = dist - maxDist;
                        this.x -= normalX * overlap * 1.5; // More aggressive
                        this.y -= normalY * overlap * 1.5;
                    }
                    
                    // ALWAYS clamp particle to ensure it's inside - multiple checks
                    const checkDx = this.x - FLUID_CIRCLE_X;
                    const checkDy = this.y - FLUID_CIRCLE_Y;
                    const checkDist = Math.sqrt(checkDx * checkDx + checkDy * checkDy);
                    if (checkDist > maxDist) {
                        const checkAngle = Math.atan2(checkDy, checkDx);
                        this.x = FLUID_CIRCLE_X + Math.cos(checkAngle) * maxDist;
                        this.y = FLUID_CIRCLE_Y + Math.sin(checkAngle) * maxDist;
                    }
                    
                    // Final safety check - one more time to be absolutely sure
                    const finalDx = this.x - FLUID_CIRCLE_X;
                    const finalDy = this.y - FLUID_CIRCLE_Y;
                    const finalDist = Math.sqrt(finalDx * finalDx + finalDy * finalDy);
                    if (finalDist > maxDist) {
                        const finalAngle = Math.atan2(finalDy, finalDx);
                        this.x = FLUID_CIRCLE_X + Math.cos(finalAngle) * maxDist;
                        this.y = FLUID_CIRCLE_Y + Math.sin(finalAngle) * maxDist;
                    }
                    
                    // Check if particle has reached bottom or is on top of settled particles
                    const bottomY = FLUID_CIRCLE_Y + FLUID_CIRCLE_RADIUS;
                    
                    // Find the highest settled particle at this x position
                    let highestSettledY = bottomY;
                    for (let otherParticle of fluidParticles) {
                        if (otherParticle !== this && otherParticle.settled) {
                            const dx = this.x - otherParticle.x;
                            const dy = this.y - otherParticle.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            // If particles are close horizontally and other is settled below
                            if (Math.abs(dx) < this.size + otherParticle.size && 
                                otherParticle.y < highestSettledY) {
                                highestSettledY = otherParticle.y - otherParticle.size - this.size;
                            }
                        }
                    }
                    
                    // Settle if reached bottom or on top of other settled particles
                    // Add minimum spacing to prevent clumping
                    const minSettledSpacing = this.size * 0.3; // Minimum spacing between settled particles
                    if (this.y >= highestSettledY - minSettledSpacing && Math.abs(this.vy) < 10) {
                        this.y = highestSettledY - minSettledSpacing;
                        this.vy = 0;
                        this.vx *= 0.9; // Strong friction when settled
                        this.settled = true;
                    }
                    
                    // Slow down particles inside circle
                    if (!this.settled) {
                        this.vx *= 0.95;
                        this.vy *= 0.95;
                    }
                }
                
                // Particles inside the circle should not decay - they accumulate as fluid
                // Check if particle is inside circle (reuse variables from above)
                const isInsideCircle = isBelowOpening && dist < FLUID_CIRCLE_RADIUS;
                
                // FINAL SAFETY CHECK: If particle is inside circle, ensure it never escapes
                if (isInsideCircle) {
                    const finalDx = this.x - FLUID_CIRCLE_X;
                    const finalDy = this.y - FLUID_CIRCLE_Y;
                    const finalDist = Math.sqrt(finalDx * finalDx + finalDy * finalDy);
                    const finalMaxDist = FLUID_CIRCLE_RADIUS - this.size - 1.0; // Larger safety margin
                    if (finalDist > finalMaxDist) {
                        const finalAngle = Math.atan2(finalDy, finalDx);
                        this.x = FLUID_CIRCLE_X + Math.cos(finalAngle) * finalMaxDist;
                        this.y = FLUID_CIRCLE_Y + Math.sin(finalAngle) * finalMaxDist;
                    }
                }
                
                // Don't decay particles inside circle or settled particles - they accumulate as fluid
                if (isInsideCircle || this.settled) {
                    // Particles inside circle stay forever and accumulate
                    this.life = 1.0;
                } else {
                    // Only particles outside circle decay
                    this.life -= deltaTime * 0.5;
                }
            }
            
            draw() {
                push();
                colorMode(HSB, 360, 100, 100);
                const alpha = (this.life / this.maxLife) * 255;
                
                // Fluid effect - draw with blur/glow to create liquid appearance
                // Draw multiple overlapping circles for fluid-like merging
                for (let i = 0; i < 3; i++) {
                    const blurAlpha = alpha * (0.4 - i * 0.1);
                    const blurSize = this.size * (1 + i * 0.3);
                    fill(this.hue, 100, 100, blurAlpha);
                    noStroke();
                    ellipse(this.x, this.y, blurSize * 2, blurSize * 2);
                }
                
                // Main particle
                fill(this.hue, 100, 100, alpha);
                noStroke();
                ellipse(this.x, this.y, this.size * 2, this.size * 2);
                pop();
            }
            
            isDead() {
                // Settled particles never die - they accumulate at the bottom
                if (this.settled) {
                    return false;
                }
                return this.life <= 0;
            }
        }
        
        // Ball class
        class Ball {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 50; // Small random horizontal velocity
                this.vy = 0;
                this.radius = BALL_RADIUS;
                this.exploded = false;
                // Color cycle timer for Red → Green → Blue gradient
                this.ballColorTimer = Math.random() * (BALL_COLOR_CYCLE_MAX - BALL_COLOR_CYCLE_MIN) + BALL_COLOR_CYCLE_MIN;
                this.ballColorCycleDuration = BALL_COLOR_CYCLE_MIN + Math.random() * (BALL_COLOR_CYCLE_MAX - BALL_COLOR_CYCLE_MIN);
            }
            
            update(deltaTime, pegs, multipliers) {
                if (this.exploded) return;
                
                // Update color timer for gradient cycling
                this.ballColorTimer = (this.ballColorTimer + deltaTime) % this.ballColorCycleDuration;
                
                // Apply gravity
                this.vy += GRAVITY * deltaTime;
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Check collision with triangle walls
                this.checkWallCollision();
                
                // Check collision with pegs
                for (let peg of pegs) {
                    const dx = this.x - peg.x;
                    const dy = this.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.radius + peg.radius) {
                        // Collision detected
                        const angle = Math.atan2(dy, dx);
                        const normalX = Math.cos(angle);
                        const normalY = Math.sin(angle);
                        
                        // Reflect velocity
                        const dot = this.vx * normalX + this.vy * normalY;
                        this.vx = (this.vx - 2 * dot * normalX) * BOUNCE_DAMPING;
                        this.vy = (this.vy - 2 * dot * normalY) * BOUNCE_DAMPING;
                        
                        // Separate ball from peg
                        const overlap = (this.radius + peg.radius) - distance;
                        this.x += normalX * overlap;
                        this.y += normalY * overlap;
                        
                        // Play sound effect for peg bounce only
                        playSound(400 + Math.random() * 200, 0.08, 0.25);
                    }
                }
                
                // Check collision with multipliers (using circle-rectangle intersection)
                for (let multiplier of multipliers) {
                    if (multiplier.intersectsCircle(this.x, this.y, this.radius)) {
                        // Hit multiplier - explode!
                        this.explode(multiplier.multiplier);
                        return;
                    }
                }
                
                // Apply friction
                this.vx *= FRICTION;
            }
            
            // Check collision with triangle walls
            checkWallCollision() {
                const WALL_OFFSET = PEG_RADIUS + 7; // Moved outwards a few pixels
                const rowWidth = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
                const firstRowY = TRIANGLE_TOP_Y;
                const lastRowY = TRIANGLE_BOTTOM_Y;
                
                // Check if ball is within the wall's Y range
                if (this.y >= firstRowY && this.y <= lastRowY) {
                    // Find which row the ball is in
                    const rowIndex = Math.floor((this.y - firstRowY) / PEG_SPACING_Y);
                    const clampedRow = Math.max(0, Math.min(ROWS - 1, rowIndex));
                    
                    // Calculate peg positions for this row
                    const numPegs = 3 + clampedRow;
                    const rowWidth_p = (numPegs - 1) * PEG_SPACING_X;
                    const startX = TRIANGLE_LEFT_X + (rowWidth - rowWidth_p) / 2;
                    const endX = startX + rowWidth_p;
                    
                    // Calculate wall positions for this row
                    const leftWallX = startX - WALL_OFFSET;
                    const rightWallX = endX + WALL_OFFSET;
                    
                    // Interpolate between rows for smooth collision
                    const rowY = firstRowY + clampedRow * PEG_SPACING_Y;
                    const nextRowY = firstRowY + (clampedRow + 1) * PEG_SPACING_Y;
                    const t = (this.y - rowY) / (nextRowY - rowY);
                    
                    let leftWallX_interp, rightWallX_interp;
                    if (clampedRow < ROWS - 1) {
                        const nextNumPegs = 3 + clampedRow + 1;
                        const nextRowWidth_p = (nextNumPegs - 1) * PEG_SPACING_X;
                        const nextStartX = TRIANGLE_LEFT_X + (rowWidth - nextRowWidth_p) / 2;
                        const nextEndX = nextStartX + nextRowWidth_p;
                        const nextLeftWallX = nextStartX - WALL_OFFSET;
                        const nextRightWallX = nextEndX + WALL_OFFSET;
                        
                        leftWallX_interp = leftWallX + (nextLeftWallX - leftWallX) * t;
                        rightWallX_interp = rightWallX + (nextRightWallX - rightWallX) * t;
                    } else {
                        leftWallX_interp = leftWallX;
                        rightWallX_interp = rightWallX;
                    }
                    
                    // Left wall collision (no sound - only pegs make sound)
                    if (this.x < leftWallX_interp + this.radius) {
                        this.x = leftWallX_interp + this.radius;
                        this.vx = Math.abs(this.vx) * BOUNCE_DAMPING;
                    }
                    
                    // Right wall collision (no sound - only pegs make sound)
                    if (this.x > rightWallX_interp - this.radius) {
                        this.x = rightWallX_interp - this.radius;
                        this.vx = -Math.abs(this.vx) * BOUNCE_DAMPING;
                    }
                }
            }
            
            explode(multiplier) {
                if (this.exploded) return;
                this.exploded = true;
                
                // Create fluid particles with ball's current color (only downward)
                const ballColor = this.getBallColor();
                for (let i = 0; i < FLUID_PARTICLES_PER_BALL; i++) {
                    // Angle between Math.PI/4 (down-right) and 3*Math.PI/4 (down-left) - only downward
                    const angle = Math.PI / 4 + Math.random() * (Math.PI / 2);
                    const speed = Math.random() * 100 + 50;
                    const particle = new FluidParticle(this.x, this.y);
                    particle.vx = Math.cos(angle) * speed;
                    particle.vy = Math.sin(angle) * speed; // Always positive (downward)
                    // Convert RGB to HSB for particle
                    push();
                    colorMode(RGB, 255);
                    const c = color(ballColor[0], ballColor[1], ballColor[2]);
                    colorMode(HSB, 360, 100, 100);
                    particle.hue = hue(c);
                    pop();
                    fluidParticles.push(particle);
                }
                
                // Play explosion sound
                playSound(300, 0.15, 0.4);
                
                // Immediately spawn all new balls at the top of the triangle
                const firstRowPegs = 3;
                const firstRowY = TRIANGLE_TOP_Y;
                const rowWidth = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
                const startX = TRIANGLE_LEFT_X + (rowWidth - (firstRowPegs - 1) * PEG_SPACING_X) / 2;
                const middlePegX = startX + PEG_SPACING_X; // Middle peg (index 1)
                
                // Spawn all multiplier balls immediately at the top
                for (let i = 0; i < multiplier; i++) {
                    // Add slight horizontal spread so balls don't overlap exactly
                    const spreadX = (Math.random() - 0.5) * 20;
                    balls.push(new Ball(middlePegX + spreadX, firstRowY - 15));
                    totalBallsDropped++;
                }
            }
            
            // Get color based on ball's timer (Red → Green → Blue gradient)
            getBallColor() {
                const normalizedTime = this.ballColorTimer / this.ballColorCycleDuration; // 0 to 1
                
                let red, green, blue;
                
                if (normalizedTime < 1/3) {
                    // First third: Red → Green
                    const progress = normalizedTime * 3; // 0 to 1
                    red = Math.floor(255 * (1 - progress));
                    green = Math.floor(255 * progress);
                    blue = 0;
                } else if (normalizedTime < 2/3) {
                    // Second third: Green → Blue
                    const progress = (normalizedTime - 1/3) * 3; // 0 to 1
                    red = 0;
                    green = Math.floor(255 * (1 - progress));
                    blue = Math.floor(255 * progress);
                } else {
                    // Third third: Blue → Red
                    const progress = (normalizedTime - 2/3) * 3; // 0 to 1
                    red = Math.floor(255 * progress);
                    green = 0;
                    blue = Math.floor(255 * (1 - progress));
                }
                
                // Brighten colors slightly (increase intensity by 15%)
                red = Math.min(255, Math.floor(red * 1.15));
                green = Math.min(255, Math.floor(green * 1.15));
                blue = Math.min(255, Math.floor(blue * 1.15));
                
                return [red, green, blue];
            }
            
            draw() {
                if (this.exploded) return;
                
                // Neon gradient effect (Red → Green → Blue)
                const color = this.getBallColor();
                
                push();
                // Outer glow layers
                for (let i = 0; i < 4; i++) {
                    const alpha = 150 - i * 30;
                    const radius = this.radius * (1 + i * 0.2);
                    fill(color[0], color[1], color[2], alpha);
                    noStroke();
                    ellipse(this.x, this.y, radius * 2, radius * 2);
                }
                
                // Main ball
                fill(color[0], color[1], color[2]);
                noStroke();
                ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
                pop();
            }
            
            isOffScreen() {
                return this.y > CANVAS_HEIGHT + 100;
            }
        }
        
        // Create triangle pegs (3, 4, 5, 6, 7, 8 pegs per row) - centered, not stretched
        function createPegs() {
            pegs = [];
            // 6 rows: 3, 4, 5, 6, 7, 8 pegs
            for (let row = 0; row < ROWS; row++) {
                const y = TRIANGLE_TOP_Y + row * PEG_SPACING_Y;
                const rowWidth = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
                // Number of pegs: 3, 4, 5, 6, 7, 8
                const numPegs = 3 + row;
                const startX = TRIANGLE_LEFT_X + (rowWidth - (numPegs - 1) * PEG_SPACING_X) / 2;
                
                for (let col = 0; col < numPegs; col++) {
                    const x = startX + col * PEG_SPACING_X;
                    pegs.push(new Peg(x, y));
                }
            }
        }
        
        // Create multiplier boxes - positioned directly under pegs
        // Order: x10, x4, x4, x10 (left to right)
        // x10 boxes under outermost 2 pegs (0-1 and 6-7), x4 boxes under next 2 (2-3 and 4-5)
        function createMultipliers() {
            multipliers = [];
            
            // Calculate row 6 peg positions (8 pegs: 0-7)
            const lastRowPegs = 8;
            const rowWidth = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
            const lastRowWidth = (lastRowPegs - 1) * PEG_SPACING_X;
            const lastRowStartX = TRIANGLE_LEFT_X + (rowWidth - lastRowWidth) / 2;
            
            // Calculate peg positions
            const peg0X = lastRowStartX;
            const peg1X = lastRowStartX + PEG_SPACING_X;
            const peg2X = lastRowStartX + 2 * PEG_SPACING_X;
            const peg3X = lastRowStartX + 3 * PEG_SPACING_X;
            const peg4X = lastRowStartX + 4 * PEG_SPACING_X;
            const peg5X = lastRowStartX + 5 * PEG_SPACING_X;
            const peg6X = lastRowStartX + 6 * PEG_SPACING_X;
            const peg7X = lastRowStartX + 7 * PEG_SPACING_X;
            
            // Position multipliers directly under pegs, spaced evenly
            // x10 left: centered under pegs 0-1 (outermost 2 on left)
            const x10LeftCenterX = (peg0X + peg1X) / 2;
            multipliers.push(new MultiplierBox(x10LeftCenterX - MULTIPLIER_WIDTH / 2, MULTIPLIER_Y, 10, MULTIPLIER_WIDTH));
            
            // x4 left: centered under pegs 2-3 (next to x10 left)
            const x4LeftCenterX = (peg2X + peg3X) / 2;
            multipliers.push(new MultiplierBox(x4LeftCenterX - MULTIPLIER_WIDTH / 2, MULTIPLIER_Y, 4, MULTIPLIER_WIDTH));
            
            // x4 right: centered under pegs 4-5 (next to x10 right)
            const x4RightCenterX = (peg4X + peg5X) / 2;
            multipliers.push(new MultiplierBox(x4RightCenterX - MULTIPLIER_WIDTH / 2, MULTIPLIER_Y, 4, MULTIPLIER_WIDTH));
            
            // x10 right: centered under pegs 6-7 (outermost 2 on right)
            const x10RightCenterX = (peg6X + peg7X) / 2;
            multipliers.push(new MultiplierBox(x10RightCenterX - MULTIPLIER_WIDTH / 2, MULTIPLIER_Y, 10, MULTIPLIER_WIDTH));
        }
        
        // Draw triangle walls (two diagonal lines outside pegs, no bottom)
        function drawTriangle() {
            stroke(255, 255, 255);
            strokeWeight(2);
            noFill();
            
            // Calculate wall offset (position outside pegs, ensuring no intersection)
            const WALL_OFFSET = PEG_RADIUS + 7; // Moved outwards a few pixels
            
            const rowWidth = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
            
            // Calculate wall positions for each row based on outermost pegs
            // We'll calculate points for each row and connect them
            const wallPoints = [];
            
            for (let row = 0; row < ROWS; row++) {
                const y = TRIANGLE_TOP_Y + row * PEG_SPACING_Y;
                const numPegs = 3 + row;
                const rowWidth_p = (numPegs - 1) * PEG_SPACING_X;
                const startX = TRIANGLE_LEFT_X + (rowWidth - rowWidth_p) / 2;
                const endX = startX + rowWidth_p;
                
                // Leftmost and rightmost peg positions
                const leftmostPegX = startX;
                const rightmostPegX = endX;
                
                // Wall positions (outside pegs)
                const leftWallX = leftmostPegX - WALL_OFFSET;
                const rightWallX = rightmostPegX + WALL_OFFSET;
                
                wallPoints.push({
                    y: y,
                    leftX: leftWallX,
                    rightX: rightWallX
                });
            }
            
            // Draw left wall by connecting all left points
            for (let i = 0; i < wallPoints.length - 1; i++) {
                line(wallPoints[i].leftX, wallPoints[i].y, 
                     wallPoints[i + 1].leftX, wallPoints[i + 1].y);
            }
            
            // Draw right wall by connecting all right points
            for (let i = 0; i < wallPoints.length - 1; i++) {
                line(wallPoints[i].rightX, wallPoints[i].y, 
                     wallPoints[i + 1].rightX, wallPoints[i + 1].y);
            }
        }
        
        // Draw fluid collection circle (white, with top section removed)
        function drawFluidCircle() {
            // Calculate triangle wall endpoints at the last row to align semicircle
            const WALL_OFFSET = PEG_RADIUS + 7;
            const lastRowPegs = 8;
            const rowWidth = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
            const lastRowWidth = (lastRowPegs - 1) * PEG_SPACING_X;
            const lastRowStartX = TRIANGLE_LEFT_X + (rowWidth - lastRowWidth) / 2;
            const lastRowEndX = lastRowStartX + lastRowWidth;
            
            // Get wall endpoints (aligned with triangle walls)
            const openingLeftX = lastRowStartX - WALL_OFFSET; // Left wall endpoint
            const openingRightX = lastRowEndX + WALL_OFFSET; // Right wall endpoint
            const openingTopY = FLUID_CIRCLE_Y - FLUID_CIRCLE_RADIUS; // Top of circle
            
            // Calculate opening width and depth
            const openingWidth = openingRightX - openingLeftX;
            const openingDepth = Math.sqrt(FLUID_CIRCLE_RADIUS * FLUID_CIRCLE_RADIUS - 
                                          (openingWidth / 2) * (openingWidth / 2));
            const openingBottomY = openingTopY + openingDepth; // Bottom of opening
            
            // Draw circle with TOP section removed
            push();
            noFill();
            stroke(255, 255, 255);
            strokeWeight(3);
            
            // Calculate angles for the opening (at the top of circle)
            // The opening is at the top, so we draw the bottom arc
            const dx1 = openingLeftX - FLUID_CIRCLE_X;
            const dy1 = openingBottomY - FLUID_CIRCLE_Y; // Point on circle at opening bottom
            const dx2 = openingRightX - FLUID_CIRCLE_X;
            const dy2 = openingBottomY - FLUID_CIRCLE_Y;
            
            const leftAngle = Math.atan2(dy1, dx1);
            const rightAngle = Math.atan2(dy2, dx2);
            
            // Draw arc from right opening, around bottom, to left opening (excluding top)
            // Start from right, go clockwise around bottom to left
            let startAngle = rightAngle;
            let endAngle = leftAngle;
            
            // If left angle is less than right, we need to wrap around
            if (leftAngle < rightAngle) {
                endAngle = leftAngle + Math.PI * 2;
            }
            
            arc(FLUID_CIRCLE_X, FLUID_CIRCLE_Y, FLUID_CIRCLE_RADIUS * 2, FLUID_CIRCLE_RADIUS * 2, 
                startAngle, endAngle, OPEN);
            
            // Removed the line connecting the two ends of the semicircle
            pop();
            
            // Draw fluid particles and fluid fill
            push();
            colorMode(HSB, 360, 100, 100);
            
            // Calculate opening position (same as above, aligned with triangle walls)
            const WALL_OFFSET2 = PEG_RADIUS + 7;
            const lastRowPegs2 = 8;
            const rowWidth2 = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
            const lastRowWidth2 = (lastRowPegs2 - 1) * PEG_SPACING_X;
            const lastRowStartX2 = TRIANGLE_LEFT_X + (rowWidth2 - lastRowWidth2) / 2;
            const lastRowEndX2 = lastRowStartX2 + lastRowWidth2;
            const openingLeftX2 = lastRowStartX2 - WALL_OFFSET2; // Left wall endpoint
            const openingRightX2 = lastRowEndX2 + WALL_OFFSET2; // Right wall endpoint
            const openingY2 = FLUID_CIRCLE_Y - FLUID_CIRCLE_RADIUS;
            const openingWidth2 = openingRightX2 - openingLeftX2;
            const openingHeight2 = Math.sqrt(FLUID_CIRCLE_RADIUS * FLUID_CIRCLE_RADIUS - 
                                           (openingWidth2 / 2) * (openingWidth2 / 2));
            const openingBottomY2 = openingY2 + openingHeight2;
            
            // Calculate fluid level at bottom (based on settled particles)
            const bottomY = FLUID_CIRCLE_Y + FLUID_CIRCLE_RADIUS;
            let maxFluidY = bottomY;
            let settledParticleCount = 0;
            let avgHue = 0;
            
            for (let particle of fluidParticles) {
                const dx = particle.x - FLUID_CIRCLE_X;
                const dy = particle.y - FLUID_CIRCLE_Y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if particle is inside circle and below opening
                const isBelowOpening = particle.y > openingBottomY2;
                if (dist < FLUID_CIRCLE_RADIUS && isBelowOpening) {
                    // Draw particle
                    const alpha = particle.settled ? 255 : (particle.life / particle.maxLife) * 200;
                    fill(particle.hue, 100, 100, alpha);
                    noStroke();
                    ellipse(particle.x, particle.y, particle.size * 2, particle.size * 2);
                    
                    // Track settled particles for fluid fill
                    if (particle.settled) {
                        settledParticleCount++;
                        avgHue += particle.hue;
                        if (particle.y < maxFluidY) {
                            maxFluidY = particle.y;
                        }
                    }
                }
            }
            
            // Draw fluid fill at bottom (atomized liquid effect - smoother, more merged)
            if (settledParticleCount > 0) {
                avgHue = avgHue / settledParticleCount;
                const fluidTopY = Math.min(maxFluidY, bottomY - 5); // Leave small gap at bottom
                const fluidHeight = bottomY - fluidTopY;
                
                if (fluidHeight > 0) {
                    // Draw filled fluid rectangle with smoother, more liquid-like appearance
                    fill(avgHue, 100, 100, 200); // More opaque for liquid effect
                    noStroke();
                    
                    // Calculate the width of the fluid at this height
                    const fluidCenterY = (fluidTopY + bottomY) / 2;
                    const dyFromCenter = fluidCenterY - FLUID_CIRCLE_Y;
                    const fluidRadiusAtHeight = Math.sqrt(FLUID_CIRCLE_RADIUS * FLUID_CIRCLE_RADIUS - dyFromCenter * dyFromCenter);
                    
                    // Draw fluid fill with rounded edges for liquid effect
                    rect(FLUID_CIRCLE_X - fluidRadiusAtHeight, fluidTopY, 
                         fluidRadiusAtHeight * 2, fluidHeight);
                    
                    // Check if fluid reached the bottom of the boxes (game end condition)
                    const boxBottomY = MULTIPLIER_Y + MULTIPLIER_HEIGHT;
                    if (fluidTopY <= boxBottomY && !gameStopped) {
                        gameStopped = true;
                        gameStarted = false; // Stop dropping balls
                    }
                }
            }
            pop();
        }
        
        // Setup function
        function setup() {
            createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
            background(0);
            lastFrameTime = millis();
            
            createPegs();
            createMultipliers();
            
            // Setup start button
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            
            if (startButton) {
                startButton.addEventListener('click', async () => {
                    startButton.classList.add('hidden');
                    if (restartButton) restartButton.classList.remove('hidden');
                    const ctx = initAudioContext();
                    if (ctx.state === 'suspended') {
                        await ctx.resume();
                    }
                    gameStarted = true;
                    lastBallDropTime = millis() / 1000.0;
                    dropBall();
                });
            }
            
            if (restartButton) {
                restartButton.addEventListener('click', () => {
                    resetGame();
                });
            }
        }
        
        // Drop a ball onto the middle peg of the first row
        function dropBall() {
            if (ballsToDrop > 0) {
                // First row has 3 pegs, middle peg is index 1
                const firstRowPegs = 3;
                const firstRowY = TRIANGLE_TOP_Y; // First row of pegs
                const rowWidth = TRIANGLE_RIGHT_X - TRIANGLE_LEFT_X;
                const startX = TRIANGLE_LEFT_X + (rowWidth - (firstRowPegs - 1) * PEG_SPACING_X) / 2;
                const middlePegX = startX + PEG_SPACING_X; // Middle peg (index 1)
                
                // Drop ball onto middle peg
                balls.push(new Ball(middlePegX, firstRowY - 15));
                ballsToDrop--;
                totalBallsDropped++;
            }
        }
        
        // Reset game
        function resetGame() {
            balls = [];
            fluidParticles = [];
            ballsToDrop = 1;
            totalBallsDropped = 0;
            gameStarted = false;
            gameStopped = false;
            lastFrameTime = millis();
            lastBallDropTime = 0;
            
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            if (startButton) startButton.classList.remove('hidden');
            if (restartButton) restartButton.classList.add('hidden');
        }
        
        // Draw function
        function draw() {
            const currentTime = millis();
            const deltaTime = (currentTime - lastFrameTime) / 1000.0;
            lastFrameTime = currentTime;
            
            // Clear canvas
            background(0);
            
            // Draw triangle outline
            drawTriangle();
            
            // Draw pegs
            pegs.forEach(peg => peg.draw());
            
            // Draw multipliers
            multipliers.forEach(mult => mult.draw());
            
            if (gameStarted && !gameStopped) {
                // Update and draw balls
                for (let i = balls.length - 1; i >= 0; i--) {
                    const ball = balls[i];
                    ball.update(deltaTime, pegs, multipliers);
                    ball.draw();
                    
                    // Remove if off screen or exploded
                    if (ball.isOffScreen() || ball.exploded) {
                        balls.splice(i, 1);
                    }
                }
                
                // Drop new balls continuously (only if game not stopped)
                const currentTime = millis() / 1000.0;
                if (ballsToDrop > 0 && currentTime - lastBallDropTime >= BALL_DROP_INTERVAL) {
                    dropBall();
                    lastBallDropTime = currentTime;
                }
            }
            
            // Update and draw fluid particles (always, even when stopped)
            if (gameStarted || gameStopped) {
                
                // Update and draw fluid particles
                for (let i = fluidParticles.length - 1; i >= 0; i--) {
                    const particle = fluidParticles[i];
                    particle.update(deltaTime);
                    particle.draw();
                    
                    if (particle.isDead()) {
                        fluidParticles.splice(i, 1);
                    }
                }
            }
            
            // Draw fluid collection circle
            drawFluidCircle();
            
            // Draw stats
            fill(255, 255, 255);
            textAlign(LEFT, TOP);
            textSize(16);
            noStroke();
            if (gameStopped) {
                // Show final ball count when fluid reaches top
                textSize(24);
                textStyle(BOLD);
                text(`FLUID FULL!`, 20, 20);
                text(`Total balls: ${totalBallsDropped}`, 20, 55);
            } else if (gameStarted) {
                // Show total dropped counter near top left, closer to triangle
                text(`Total dropped: ${totalBallsDropped}`, 20, TRIANGLE_TOP_Y - 30);
            }
        }
    </script>
</body>
</html>

